The full-stack web application I chose for this category is the Travlr Getaways Admin Dashboard, built with Angular, Node/Express, and MongoDB. The original version of this project was created earlier in my computer science program and has been refined over time to show my growing skills in backend development and database design. For this update, I focused on improving the database structure and backend query performance to make the data layer more reliable and scalable. 

I included this project in my ePortfolio because it highlights my ability to design, normalize, and optimize database structures in a production-style environment. I refined the MongoDB schema to bring all trip data into one consistent model called TripSchema, added validation rules to keep data accurate, and introduced new fields like dateStart and dateEnd to support both single-day and multi-day trips. I also added several indexes to speed up queries, especially sorting and filtering and created optional migration and seeding scripts to make data management repeatable and consistent. I enhanced the /api/trips endpoint to handle advanced queries like server-side sorting, pagination, and date-range filtering. These updates improved performance and maintainability while keeping full compatibility with the Angular front end. 

This enhancement directly supports the course outcomes I set in Module One, which focus on applying data management and modeling techniques to ensure data integrity, scalability, and efficiency. By adding schema validation, indexing strategies, and modular migration scripts, I demonstrated my ability to use database technologies to build secure, efficient, and flexible software systems. No changes were needed to my original plan since this enhancement met all of the intended objectives. 

Working on this enhancement gave me a much deeper understanding of how backend systems interact with database layers. I learned how schema design and indexing choices directly affect performance and how to balance flexibility with efficiency when structuring queries. One important takeaway was learning how to maintain backward compatibility while updating the schema, for example, adding virtual fields like title and location so older code would still work. Some of the main challenges involved designing indexes that worked well for different query types without adding redundancy and testing date range filters to make sure results were accurate. This project strengthened my confidence in building scalable, database driven systems and reinforced the importance of designing for both performance and long-term maintainability. 
