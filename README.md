The product I selected from this category is the Travlr Getaways admin panel, a full-stack web application built with Angular, Node/Express, and MongoDB. This app was first created as coursework and has been refined over time throughout my program. The main focus of this update was improving the use of algorithms and data structures to make the application more efficient and scalable. The work included adding server-side sorting, filtering, and paging, along with client-side improvements like debounced search, request cancellation with RxJS, and using Sets and Maps for quicker lookups and data handling. 

I included this project in my ePortfolio because it shows my ability to apply algorithmic thinking and data structure knowledge in a real-world project. By moving away from simple list scans and full dataset loads, I was able to show that the application could scale efficiently as the data grew. Pagination, sorting, and caching highlight my skills in structuring queries and handling results, while the debounced search and RxJS work show that I can manage async operations and improve client-side performance. These updates demonstrate not only technical ability but also how system design can directly improve user experience. 

This enhancement aligns with the outcomes I set back in Module One specifically, using algorithms and data structures to improve efficiency and scalability in software systems. I didn’t need to change my original plan since the work directly covered those outcomes. 

Through this process, I learned important lessons about balancing backend and frontend responsibilities when working with data. On the backend, I saw how critical it is to enforce limits on queries to protect resources, while on the frontend, managing state properly helps avoid unnecessary network calls. One challenge I ran into was making caching with ETags work correctly and integrate smoothly with Angular’s request logic. Another was structuring Angular components so pagination and debounced search worked together without causing stale or overlapping requests. Working through these challenges gave me a stronger understanding of asynchronous programming and how client and server performance depend on each other. 
